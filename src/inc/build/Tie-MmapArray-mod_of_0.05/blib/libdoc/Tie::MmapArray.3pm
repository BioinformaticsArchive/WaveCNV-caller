.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::MmapArray 3"
.TH Tie::MmapArray 3 "2013-04-16" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::MmapArray \- mmap a file as a tied array
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Tie::MmapArray;
\&
\&    tie @array, \*(AqTie::MmapArray\*(Aq, $filename;
\&    tie @array, \*(AqTie::MmapArray\*(Aq, $filename, $template;
\&    tie @array, \*(AqTie::MmapArray\*(Aq, $filename, { template => $template,
\&                                               nels     => 0,
\&                                               mode     => "rw",
\&                                               shared   => 1,
\&                                               offset   => 0 };
\&
\&    $len = (tied @array)\->record_size;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Tie::MmapArray module lets you use mmap to map in a file as a perl
array rather than reading the file into dynamically allocated
memory. It depends on your operating system supporting \s-1UNIX\s0 or
\&\s-1POSIX\s0.1b mmap, of course.  (Code to use the equivalent functions on
Win32 platforms has been contributed but has not been tested yet.)
.PP
The type of array elements is defined by the \fItemplate\fR argument or
option.  This is a Perl \fIpack()\fR\-style template, which defaults to \*(L"i\*(R".
The template may be an array reference, in which case the elements are
defined by pairs of name and template for each element.  A template
string may define multiple fields, in which case that element is
regarded as an array of fields (which need not be of the same type).
.PP
The following example shows the utmp file on Linux mapped to an array:
.PP
.Vb 10
\&    tie @utmp, \*(AqTie::MmapArray\*(Aq, \*(Aq/var/log/utmp\*(Aq,
\&        { mode     => "rw",
\&          template => [ ut_type    => \*(Aqs\*(Aq,
\&                        ut_pid     => \*(Aqi\*(Aq,      # pid_t
\&                        ut_line    => \*(Aqa12\*(Aq,
\&                        ut_id      => \*(Aqa4\*(Aq,
\&                        ut_user    => \*(Aqa32\*(Aq,
\&                        ut_host    => \*(Aqa256\*(Aq,
\&                        ut_exit    => [ # struct exit_status
\&                                        e_termination => \*(Aqs\*(Aq,
\&                                        e_exit        => \*(Aqs\*(Aq ],
\&                        ut_session => \*(Aql\*(Aq,
\&                        ut_tv      => [ # struct timeval
\&                                        tv_sec  => \*(Aql\*(Aq,
\&                                        tv_usec => \*(Aql\*(Aq ],
\&                        ut_addr_v6 => \*(Aql4\*(Aq,
\&                        pad        => \*(Aqa20\*(Aq ] };
.Ve
.PP
This can be scanned as follows:
.PP
.Vb 4
\&    for (my $i = 0; $i < @utmp; $i++) {
\&        printf("pid: %d, user: %s\en",
\&               $utmp[$i]\->{ut_pid}, $utmp[$i]\->{ut_user});
\&    }
.Ve
.PP
The following subset of \fIpack()\fR template letters is supported:
.IP "i" 4
.IX Item "i"
signed integer (default)
.IP "I" 4
.IX Item "I"
unsigned integer
.IP "c" 4
.IX Item "c"
signed character (one byte integer)
.IP "c" 4
.IX Item "c"
unsigned character (one byte integer)
.IP "s" 4
.IX Item "s"
signed short integer
.IP "S" 4
.IX Item "S"
unsigned short integer
.IP "n" 4
.IX Item "n"
unsigned short integer in network byte order
.IP "l" 4
.IX Item "l"
signed long integer
.IP "L" 4
.IX Item "L"
unsigned long integer
.IP "N" 4
.IX Item "N"
unsigned long integer in network byte order
.IP "f" 4
.IX Item "f"
float
.IP "d" 4
.IX Item "d"
double
.IP "a\fIN\fR" 4
.IX Item "aN"
fixed-length, null-padded \s-1ASCII\s0 string of length \fIN\fR
.IP "A\fIN\fR" 4
.IX Item "AN"
fixed-length, space-padded \s-1ASCII\s0 string of length \fIN\fR
.IP "Z\fIN\fR" 4
.IX Item "ZN"
fixed-length, null-terminated \s-1ASCII\s0 string of length \fIN\fR
.PP
The size of the array is defined by the \fInels\fR option.  If this is
zero then it is calculated as the file size divided by the element
size.
.PP
If the file size is smaller than the size required for the requested
elements then a single zero byte will be written to the final byte of
the requested size.  This seems to prevent the module dying with a
segmentation or bus error if memory is accessed beyond the end of the
file and generally results in a file with holes (unallocated blocks).
Precise details of the behaviour of the module are subject to change.
.SH "BUGS, RESTRICTIONS AND FUTURE DIRECTIONS"
.IX Header "BUGS, RESTRICTIONS AND FUTURE DIRECTIONS"
This is version 0.02 of the module and there are likely to be many
bugs.  The interface may change as the result of feedback.
.PP
The options \fImode\fR and \fIshared\fR are not yet used.
.PP
Not all pack letters are implemented yet.
.PP
push, pop, shift, unshift, and splice operations are not yet
supported.  It is debateable whether they should be as they could be
very expensive if the mmaped file was large (say a Gigabyte or two).
Perhaps there should be an option to explicitly allow these
operations.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Ford <A.Ford@ford\-mason.co.uk>, 27 December 1999.
.SH "CREDITS"
.IX Header "CREDITS"
The module was inspired by Malcolm Beatie's Mmap module.
.PP
Reini Urban <rurban@x\-ray.at> provided intial code for Win32 platforms.
